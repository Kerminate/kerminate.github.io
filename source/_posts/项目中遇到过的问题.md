---
title: 项目中遇到过的问题与技巧
date: 2018-01-03 17:42:08
tags: 技术帖
---
记录开发过程中遇到的一些问题和一些技巧。

## 坑点
- 使用vue的ui框架时，比如element,iview等，需要给组件绑定原生事件，可以在事件后加.native。例如element的input组件绑定键盘事件可以这么写@keyup.enter.native="add" 详见[vue的官方教程](https://cn.vuejs.org/v2/guide/components.html#%E7%BB%99%E7%BB%84%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6)

## 面试题
- 不用循环生成100长度都为1的数组,详见[es6](http://es6.ruanyifeng.com/#docs/array#Array-from)

```
new Array(100).fill(1)
Array.from({length: 1}, () => 1)
Array.from({length: 1}).map(() => 1)
```
<!--more-->

## webpack中css预处理器的配置
```
sass: cnpm install node-sass sass-loader --save-dev
less: cnpm install less less-loader --save-dev
stylus: cnpm install stylus stylus-loader --save-dev
```

## 使用node和chrome调试
进入到项目当前文件，比如要调试 d/Leetcode/045/main.js 文件，git bash进入到 d/Leetcode/045/, 输入命令
```
node --inspect-brk main
```

## 使用npm启动项目
在windows本地调试时使用 `npm run dev` 启动项目，用 `ctrl + c` 停止，会导致进程没有结束，这时需要在windows找到该项目的进程并结束
```
netstat -ano | findstr 8080 //找到8080端口正在运行的进程
taskkill /f /pid xxx // 强行结束pid为xxx的进程
```
还有一种方法，使用yarn代替npm，`yarn run dev` 启动项目，不会产生上述的问题

## mongoose 里保存 mixed 类型的数据
在 mongoose 对 type 为 mixed 的数据作修改时，save 操作时会保存不进去。
```javascript
contest.ranklist = ranklist
contest.markModified('ranklist')
await contest.save()
```
保存时对改变的字段进行 markModified 操作，再 save 后可以保存对数据的操作。

## react 中批量导入图片
```javascript
const requireContext = require.context('../img', true, /^\.\/.*\.png$/)
const images = requireContext.keys().map(requireContext)
```
该方法的缺点是导入顺序是文件里的图片顺序，image 数组保存的是图片的 base64 编码，无法在代码中通过名字确认是哪张图

## linux 命令行常用快捷键
Ctrl + A  // 光标移到行首
Ctrl + E  // 光标移到行尾
Ctrl + K  // 删除之行尾

## linux 常用指令
```shell
echo $(cat a) > b  // 将文件a输出至文件b
echo $(cat a) >> b  // 将文件a追加至文件b
```
## npm >= 5.0 时更新包
```
npm install xxx@yyy --save-dev  // 手动指定安装版本
```

## reset.css
做 PC 端时，不同的浏览器的默认样式之间存在差别，使用 reset.css 来将浏览器的默认样式全部覆盖掉，达到统一样式的效果。
[reset.css](https://meyerweb.com/eric/tools/css/reset/)

## 使用 proxy 代替 Object.defineProperty
对象级别的优化已经很极致了，工程代码中也没有机会帮助 JS 引擎做得更好，值得注意的是不要对数组使用 Object 对象下的方法，尤其是 defineProperty，因为这会让 JS 引擎在存储数组元素时，使用 Dictionary Elements 结构替代 Elements，而 Elements 结构是共享 PropertyDescriptor 的。

但也有难以避免的情况，比如使用 Object.defineProperty 监听数组变化时，就不得不破坏 JS 引擎渲染了。

使用 proxy 监听数组变化，这并不会改变 Elements 的结构，所以这也从另一个侧面证明了使用 proxy 监听对象变化比 Object.defineProperty 更优，因为 Object.defineProperty 会破坏 JS 引擎对数组做的优化。

**原文可参考 [JS 引擎基础之 Shapes and Inline Caches](https://github.com/dt-fe/weekly/blob/master/62.%E7%B2%BE%E8%AF%BB%E3%80%8AJS%20%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80%E4%B9%8B%20Shapes%20and%20Inline%20Caches%E3%80%8B.md)**